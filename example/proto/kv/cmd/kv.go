// Code generated by protoc-gen-hcplugin. DO NOT EDIT.
package cmd

import (
	cli "github.com/urfave/cli"

	exec "os/exec"

	fmt "fmt"

	grpc "github.com/da-moon/protoc-gen-hcplugin/example/proto/kv/grpc"

	handler "github.com/da-moon/protoc-gen-hcplugin/example/proto/kv/handler/cmd"

	plugin "github.com/hashicorp/go-plugin"

	rpc "github.com/da-moon/protoc-gen-hcplugin/example/proto/kv/net-rpc"

	shared "github.com/da-moon/protoc-gen-hcplugin/example/proto/kv/shared"

	stacktrace "github.com/palantir/stacktrace"
)

// KV - cli command based on service name
var KV = []cli.Command{
	{
		Name:    "kv",
		Usage:   "KV Engine Demo Implmentation",
		Aliases: []string{"key-value"},
		Flags: cli.FlagsByName{
			cli.StringFlag{
				Name:  "kv-binary",
				Usage: "kv engine binary path",
				Value: "",
			},
		},
		Before: func(ctx *cli.Context) error {
			// We don't want to see the plugin logs.
			// log.SetOutput(ioutil.Discard)
			// We're a host. Start by launching the plugin process.
			path := ctx.String("kv-binary")
			if len(path) == 0 {
				err := stacktrace.NewError("kv plugin engine binary path is empty")
				fmt.Println(err)
				return err
			}
			client := plugin.NewClient(&plugin.ClientConfig{
				HandshakeConfig: shared.HandshakeConfig,
				Plugins: map[string]plugin.Plugin{
					"kv_grpc": &grpc.Plugin{},
					"kv":      &rpc.Plugin{},
				},
				Cmd: exec.Command("sh", "-c", path),
				AllowedProtocols: []plugin.Protocol{
					plugin.ProtocolNetRPC, plugin.ProtocolGRPC},
			})
			defer client.Kill()
			// Connect via RPC
			rpcClient, err := client.Client()
			if err != nil {
				err = stacktrace.Propagate(err, "Client failed to return the protocol client for kv engine connection")
				fmt.Println(err)
				return err
			}
			// Request the plugin
			raw, err := rpcClient.Dispense("kv_grpc")
			if err != nil {
				err = stacktrace.Propagate(err, "RPC Client could not dispense a new instance of kv_grpc")
				fmt.Println(err)
				return err
			}
			// We should have a kv store now! This feels like a normal interface
			// implementation but is in fact over an RPC connection.
			handler.Client = raw.(shared.KVInterface)
			return nil
		},

		Subcommands: []cli.Command{
			Get,
			Put,
		},
	},
}

// Get - Get cli subcommand
var Get = cli.Command{
	Name:    "get",
	Usage:   "",
	Aliases: []string{},
	Action:  handler.Get,
}

// Put - Put cli subcommand
var Put = cli.Command{
	Name:    "put",
	Usage:   "",
	Aliases: []string{},
	Action:  handler.Put,
}
